<!DOCTYPE html><html class="ua_js_no"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Solved problems / Methodology / BEM</title><script>(function(e,c){e[c]=e[c].replace(/(ua_js_)no/g,"$1yes");})(document.documentElement,"className");</script><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,600,700&amp;subset=cyrillic"/><link rel="stylesheet" href="/bem.info/en/methodology.min.css"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/><meta property="og:image" content="https://ru.bem.info/og_image/logo_theme_stripe.png"/><meta property="og:url" content="/methodology/solved-problems/"/><meta property="og:type" content="article"/><meta property="og:description" content="Solved problems"/><meta property="og:keywords" content="methodology"/></head><body class="page"><div class="header i-bem" data-bem='{"header":{}}'><div class="header__layout"><a class="logo header__logo" href="/bem.info/en/"><svg class="logo__logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 101.7 84"><path d="M0 13h23.8v7H0zM0 0h23.8v7H0zm42.7 25.9H0v7h41.1c4.5 0 15 .1 18.9 6.4v-3.9c-1.9-6.2-7.5-9.5-17.3-9.5zm.1 13H0v7h41.1c10 0 16.3.4 18.9 1.8v-3.1c-2-4.9-10.4-5.7-17.2-5.7zm-.1 33H0v-7h41.1c4.5 0 15-.1 18.9-6.4v3.9c-1.9 6.2-7.5 9.5-17.3 9.5zm.1-13H0v-7h41.1c10 0 16.3-.4 18.9-1.8v3.1c-2 4.9-10.4 5.7-17.2 5.7zM70.4 84h31.4v-4.3H71.3c-2.7 0-9.1-.1-11.4-3.8v2.4C61 82 64.4 84 70.4 84zm-.1-7.9h31.4v-4.3H71.3c-6.1 0-9.9-.2-11.4-1.1v1.9c1.2 3 6.3 3.5 10.4 3.5z"/></svg></a><ul class="lang-switcher header__lang"><li class="lang-switcher__item"><span class="lang-switcher__current">en</span></li><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/ru/methodology/solved-problems/">ru</a></li></ul><a class="header__forum" href="/bem.info/en/forum/">Forum</a></div><div class="search header__search i-bem" data-bem='{"search":{}}'><form class="form search__form search__form_site_methodology i-bem" data-bem='{"form":{}}' action="https://yandex.com/sitesearch"><span class="input input_type_search i-bem" data-bem='{"input":{}}'><span class="input__box"><input class="input__control" name="text" placeholder="Search" autocomplete="off" type="search"/></span></span><input type="hidden" name="reqenc"/><input type="hidden" name="searchid" value="1944806"/><input type="hidden" name="l10n" value="en"/><div class="search-icon search__submit"><svg viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><circle cx="7" cy="7" r="6"/><path d="M11 11l5 5"/></svg></div></form></div><div class="header__menu"><ul class="breadcrumbs header__breadcrumbs"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/bem.info/en/methodology/">Methodology</a></li></ul><ul class="nav"><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/key-concepts/">Key concepts</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/naming-convention/">Naming convention</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/filesystem/">Filesystem</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/build/">Build</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/declarations/">Declarations</a></li><li class="nav__item nav__item_current">Solved problems</li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/history/">History</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/articles/">Articles</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/en/methodology/faq/">FAQ</a></li></ul></div><div class="header__toggle search-icon"><span class="header__toggle-line"></span></div></div><div class="sitemap i-bem" data-bem='{"sitemap":{}}'><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_methodology"><a class="sitemap__link" href="/bem.info/en/methodology/">Methodology</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/key-concepts/">Key concepts</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/naming-convention/">Naming convention</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/filesystem/">Filesystem</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/build/">Build</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/declarations/">Declarations</a></li><li class="sitemap__tree-item-1"><strong class="sitemap__current">Solved problems</strong></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/history/">History</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/articles/">Articles</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/methodology/faq/">FAQ</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_tools"><a class="sitemap__link" href="/bem.info/en/tools/">Toolbox</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/tools/bem/bem-tools/">bem-tools</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/tools/bem/enb-bem/">enb-bem</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link">Modules</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="/bem.info/en/tools/bem/bem-naming/">bem-naming</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_platform"><a class="sitemap__link">Platform</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link">Technologies</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/en/technology/i-bem/v2/i-bem-js/">i-bem</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="/bem.info/en/technology/deps/about/">DEPS</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/en/technology/bemjson/v2/bemjson/">BEMJSON</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/en/technology/bemhtml/v2/intro/">BEMHTML</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/en/technology/bemtree/v2/bemtree/">BEMTREE</a></li><div class="sitemap__tree-item-0"><a class="sitemap__link" href="/bem.info/en/libs/">Libraries</a></div><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/libs/bem-core/">bem-core</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/libs/bem-components/">bem-components</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/libs/bem-history/">bem-history</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_community"><a class="sitemap__link" href="/bem.info/en/community/">Community</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/blog/">Blog</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/events/">Events</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/en/forum/">Forum</a></li></ul></div></div><div class="article-wrap"><div class="article"><ul class="article-tags"><li class="article-tags__tag"><a class="article-tags__link" href="/bem.info/en/tags/methodology">methodology</a></li></ul><h1 class="article__heading article__heading_1" id="using-bem-to-solve-common-issues-in-web-development"><a href="#using-bem-to-solve-common-issues-in-web-development" class="article__heading-anchor"></a>Using BEM to solve common issues in web development</h1><p>The BEM methodology defines <a href="/methodology/naming-convention/">CSS selector naming conventions</a> that solve a range of web development problems and address the following issues:</p>
<ul>
<li><a href="#how-to-simplify-code-and-facilitate-refactoring">How to simplify code and facilitate refactoring</a></li>
<li><a href="#how-to-get-self-documenting-code">How to get self-documenting code</a></li>
<li><a href="#how-to-start-reusing-code-without-letting-components-influence-each-other">How to start reusing code without letting components influence each other</a></li>
<li><a href="#how-to-host-multiple-entities-on-the-same-dom-node-and-avoid-copy-and-paste">How to host multiple entities on the same DOM node and avoid copy and paste</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="how-to-simplify-code-and-facilitate-refactoring"><a href="#how-to-simplify-code-and-facilitate-refactoring" class="article__heading-anchor"></a>How to simplify code and facilitate refactoring</h2><p><strong>Problem</strong></p>
<p>During project layout, interface components are given names based on the context the developer is working with. The context is usually a page or a part of one.</p>
<p>When just one developer is working with the layout for a brief period, name collisions are easily avoided. But if multiple people are working on a project, or edits need to be made at some later point, it is difficult to keep track of component name dependencies. In large projects, modifying a single class may lead to dozens of affected pages.</p>
<p>For example, the following class names can be used for creating a navigation menu:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>They might have the following CSS rules:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>If we need to add another component containing menu items to the page, the styles for the new <code>item</code> will affect the items from the existing navigation menu.</p>
<p>Or let&#39;s say we need to change the rules for the <code>.active</code> class in the navigation menu. We can&#39;t tell from the name which components use it. For example, there could be a <code>&lt;div class=&quot;button active&quot;&gt;Click me!&lt;/div&gt;</code> button on another page. In that case, changing the rules for <code>.active</code> would affect the style of that button.</p>
<p>In order to find out whether styles can be painlessly changed for the <code>.active</code> class, the developer will have to examine the structure of the entire page or project. Any change consumes a significant amount of time just searching for dependent components.</p>
<p><strong>Solution</strong></p>
<p>The BEM methodology solves the collision issue using <a href="/methodology/naming-convention#css-selector-naming-convention">naming conventions for CSS classes</a>, providing unique names for all components and their parts.</p>
<p>Using naming conventions allows us to:</p>
<ul>
<li>Define unique names for <a href="/methodology/key-concepts#bem-entity">BEM entities</a>.</li>
<li>Track hierarchical relationships within a block.</li>
<li>Simplify the code.</li>
<li>Get <a href="#how-to-get-self-documenting-code">self-documenting code</a>.</li>
</ul>
<p>Let&#39;s take the same navigation menu example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>But we&#39;ll apply BEM naming conventions to it. The <code>nav</code> class will designate the block name, <code>nav__item</code> and <code>nav__link</code> will designate the element names, and <code>nav__item_active</code> will indicate the name of a modifier for the <code>item</code> element.</p>
<p>In this case, the entry will look like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item nav__item_active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>And the CSS will look like this:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.nav__item_active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>The new CSS class names contain all the information about the block structure. This means that we no longer need to look at the page HTML code to determine all the dependencies. The selector always contains knowledge of which blocks or elements are affected by its rules (in this case, the <code>nav__item</code> element). The developer doesn&#39;t need to think about the possibility of a <code>&lt;div class=&quot;button active&quot;&gt;Click me!&lt;/div&gt;</code> button existing somewhere, because its CSS rules will be written as <code>.button_active</code> and won&#39;t depend on the rules for the <code>active</code> modifier for the menu item (<code>nav__item_active</code>).</p>
<blockquote>
<p>Using long names has the following disadvantages:</p>
<ul>
<li>The resulting code base is heavier. This problem is solved by using <code>gzip</code>, which compresses repetitive sequences in names.</li>
<li>More time is spent on writing classes. This burden is eased by using autocomplete in the editor, along with CSS preprocessors and template engines that automatically add prefixes. Long class names provide explicit connections between parts of components, which saves time on analyzing the project architecture.</li>
</ul>
</blockquote>
<h3 class="article__heading article__heading_3" id="how-to-get-self-documenting-code"><a href="#how-to-get-self-documenting-code" class="article__heading-anchor"></a>How to get self-documenting code</h3><p><strong>Problem</strong></p>
<p>When switching to a new project, a developer invests considerable effort learning how everything is organized, where things are, and how the code works. In some cases, more time is spent on this investigation than on implementing functionality or fixing bugs.</p>
<p><strong>Solution</strong></p>
<p>One of the goals of BEM is to make it clear what a piece of code does just by the class names. The idea of self-documenting code is that looking at CSS classes, variables, and functions provides enough information on how the code works and how the interface components interact.</p>
<p>Using BEM, you can get HTML with class names that show the interaction of the following parts of code:</p>
<ul>
<li>Independent <a href="/methodology/key-concepts#block">blocks</a>.</li>
<li><a href="/methodology/key-concepts#element">Elements</a> (child components) of a block.</li>
<li><a href="/methodology/key-concepts#modifier">Modifiers</a> of a block or an element.</li>
</ul>
<p>Here is an example with a search form on a website. We won&#39;t look at the HTML. We&#39;ll try to just read the CSS and understand which part of the interface it describes.</p>
<p>Implementation of the form in a classical layout:</p>
<pre><code class="lang-css"><span class="hljs-selector-tag">form</span> {}

<span class="hljs-selector-tag">input</span>
{
    <span class="hljs-attribute">background</span>: red;
}

<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=submit]</span>
{
    <span class="hljs-attribute">background</span>: buttonface
}
</code></pre>
<p>This doesn&#39;t reflect the relationships between:</p>
<ul>
<li>Components and their parts.</li>
<li>Selectors and specific components of the interface that they are related to.</li>
</ul>
<p>Using global selectors makes the project code non-extensible, as even the smallest changes will entail edits to all the dependent rules.</p>
<p>Let&#39;s write the CSS for classes:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.field</span> {}
<span class="hljs-selector-class">.submit</span> {}
</code></pre>
<p>The code is more informative. Now it is clear that there is a form, a field, and a <code>submit</code> component. But these names still don&#39;t tell us whether <code>field</code> belongs to <code>form</code>, or what will happen if there are multiple fields or forms on the page. Once again we must return to the HTML.</p>
<p>We&#39;ll rewrite the example using <a href="/methodology/naming-convention/">BEM naming conventions</a>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.form_search</span> {}
<span class="hljs-selector-class">.form__field</span> {}
<span class="hljs-selector-class">.form__submit-button</span> {}
</code></pre>
<p>Now we can see how this code works. The CSS class names show that:</p>
<ul>
<li>There is a form implemented by the <code>form</code> block.</li>
<li>The <code>form_search</code> modifier indicates that this is a search form.</li>
<li>The form has nested elements: <code>form__field</code> and <code>form__submit-button</code>.</li>
</ul>
<p>Following the BEM naming convention allows us to understand the structure of a block without studying the HTML in detail. Even if another field appears on the page (besides <code>form__field</code>), its rules won&#39;t affect the search form elements in any way. The new field will be implemented as an element of another block, and will have its own unique name. For example, <code>attach__field</code>.</p>
<p>The BEM naming rules help to make the project code unambiguous and informative. This reduces the learning curve for other developers.</p>
<h2 class="article__heading article__heading_2" id="how-to-start-reusing-code-without-letting-components-influence-each-other"><a href="#how-to-start-reusing-code-without-letting-components-influence-each-other" class="article__heading-anchor"></a>How to start reusing code without letting components influence each other</h2><p><strong>Problem</strong></p>
<p>The developer uses a similar set of components when developing pages in the same project. For example, a page may have several types of <code>menu</code> blocks.</p>
<p>We&#39;ll use the navigation menu example to examine this problem:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>The CSS styles and <code>item</code> can be defined like this:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>If additional components containing items will be added to the page, another code block will appear with the <code>item</code> class, for example:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>In this case, the CSS can be formatted with cascades. To do this, you only need to extend the rules already written for <code>.item</code>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.snippets</span> <span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Code like this will work until the page has to be changed. For example, until you have to move the menu items, use the code somewhere else separate from the parent component, or nest a navigation menu in the <code>snippets</code> block.</p>
<p>Using cascades increases coupling of interface components of the interface. You can&#39;t fix one component without affecting the style of another one.</p>
<p><strong>Solution</strong></p>
<p><a href="/methodology/naming-convention/">CSS selector naming rules</a> make it possible to change specific points without affecting dependent components. In BEM, every block has a unique name and is self-sufficient.</p>
<p>Let&#39;s write the same code in conformance with BEM naming rules:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>In this case, adding a new <code>item</code> to the page will look like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>The <code>snippets__item</code> item will have unique CSS rules that only apply to itself:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.snippets__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Changes to <code>nav__item</code> do not affect <code>snippets__item</code>, since the items get different unique names due to the <a href="https://en.wikipedia.org/wiki/Namespace#In_programming_languages">namespace</a> defined by the block name. This allows forming independent CSS rules for all elements of a block.</p>
<p>This approach makes it possible to protect elements from mutually affecting each other â€” elements are always part of a block. The same principle is used by Shadow DOM in Web Components. However, in contrast to Shadow DOM, BEM naming conventions are applied without regard for browser compatibility.</p>
<p>The <code>snippets</code> and <code>nav</code> blocks can be reused and moved within the page or project. The uniqueness of class names based on BEM naming rules allows blocks to be independent of each other.</p>
<h3 class="article__heading article__heading_3" id="using-cascades-in-bem"><a href="#using-cascades-in-bem" class="article__heading-anchor"></a>Using cascades in BEM</h3><p>The BEM methodology allows using cascades.</p>
<p>For example, a cascade is appropriate for changing elements depending on the state of the block or the theme assigned to it:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_hovered</span> <span class="hljs-selector-class">.nav__link</span>
{
    <span class="hljs-attribute">text-decoration</span>: underline;
}
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_theme_islands</span> <span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;
}
</code></pre>
<hr>
<p><strong>Important!</strong> Applying a cascade increases code coupling and makes reuse impossible.</p>
<hr>
<h2 class="article__heading article__heading_2" id="how-to-host-multiple-entities-on-the-same-dom-node-and-avoid-copy-and-paste"><a href="#how-to-host-multiple-entities-on-the-same-dom-node-and-avoid-copy-and-paste" class="article__heading-anchor"></a>How to host multiple entities on the same DOM node and avoid copy and paste</h2><p><strong>Problem</strong></p>
<p>When working with projects, an implemented functionality may need to be reused.</p>
<p>In many cases, this issue is resolved by copying the desired chunk of code to the new component. This approach has the following disadvantages:</p>
<ul>
<li>The project&#39;s code base increases.</li>
<li>Debugging becomes more difficult if errors are detected.</li>
</ul>
<p>The consequence is that the developer has to support more lines of code, and fixes must be made separately in each implementation. This increases the time spent on debugging and maintaining the project.</p>
<p><strong>Solution</strong></p>
<p>We&#39;ll use an example that implements a universal navigation menu block and follows all the <a href="/methodology/naming-convention/">BEM naming rules</a>.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>This block could be used, for example, for navigating articles in a news section.</p>
<p>Let&#39;s assume that the news section already has the <code>articles</code> block with all the necessary CSS rules.</p>
<p>We can use a <a href="/methodology/key-concepts#mix">mix</a> to combine the implementation of the two different blocks without copying code. In other words, host the <code>nav</code> block and the <code>articles__nav</code> element on the same DOM node.</p>
<p>The code will look like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav articles__nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>This implementation allows combining the functionality of the <code>nav</code> block with the specific implementation of the <code>articles__nav</code> element (the appearance of news articles in the menu). However, there is no need to copy the existing CSS rules. If a bug is detected, only one part of the code will have to be fixed.</p>
<blockquote>
<p>In addition to blocks and elements, you can mix other BEM entities, as well. For more information about ways to use mixes in BEM, see the section <a href="/methodology/key-concepts#mix">Basic BEM concepts</a>.</p>
</blockquote>
</div><ul class="article-rewind"><li class="article-rewind__prev"><a class="article-rewind__prev-link" href="/bem.info/en/methodology/declarations/">Declarations</a></li> <li class="article-rewind__next"><a class="article-rewind__next-link" href="/bem.info/en/methodology/history/">History</a></li></ul><div class="article-amendments">If you notice a mistake or want something to supplement the article, you can always write to us at <a class="article-amendments__issue" href="https://github.com/bem/bem-method/issues/new">GitHub</a>, or correct an article using <a class="article-amendments__edit" href="http://prose.io/#bem/bem-method/blob/bem-info-data/method/solved-problems/solved-problems.en.md">prose.io.</a></div><div class="social-likes"><a class="social-likes__text">Share with world: </a><a class="social-likes__service social-likes__service_type_facebook" href="https://www.facebook.com/sharer.php?s=100&amp;url=https%3A%2F%2Fen.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=Solved%20problems&amp;image=">Facebook</a> <a class="social-likes__service social-likes__service_type_vk" href="http://vk.com/share.php?&amp;url=https%3A%2F%2Fen.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=Solved%20problems&amp;image=">VKontakte</a> <a class="social-likes__service social-likes__service_type_twitter" href="https://twitter.com/share?&amp;url=https%3A%2F%2Fen.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=Solved%20problems&amp;image=">Twitter</a></div></div><footer class="footer page-bg"><div class="legos legos_inverted"><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_width_2"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_height_2"></div><div class="legos__lego legos__lego_height_2"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_3"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div><div class="legos__lego legos__lego_height_2"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_3"></div></div><div class="footer__layout"><ul class="footer__community"><li class="footer__channel"><a class="footer__channel-link" href="https://telegram.me/bem_en">Telegram</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://www.facebook.com/groups/bem.info/">Facebook</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://twitter.com/bem_en/">Twitter</a></li></ul></div></footer><script>(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter16972024 = new Ya.Metrika({"id":"16972024","webvisor":true,"clickmap":true,"trackLinks":true,"accurateTrackBounce":true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/16972024" style="position:absolute; left:-9999px;"/></div></noscript><script src="/bem.info/en/methodology.en.min.js"></script></body></html>