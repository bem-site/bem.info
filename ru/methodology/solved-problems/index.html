<!DOCTYPE html><html class="ua_js_no"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Какие проблемы решает / Методология / БЭМ</title><script>(function(e,c){e[c]=e[c].replace(/(ua_js_)no/g,"$1yes");})(document.documentElement,"className");</script><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,600,700&amp;subset=cyrillic"/><link rel="stylesheet" href="/bem.info/ru/methodology.min.css"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/><meta property="og:image" content="https://ru.bem.info/og_image/logo_theme_stripe.png"/><meta property="og:url" content="/methodology/solved-problems/"/><meta property="og:type" content="article"/><meta property="og:description" content="Какие проблемы решает"/><meta property="og:keywords" content="methodology"/></head><body class="page"><div class="header i-bem" data-bem='{"header":{}}'><div class="header__layout"><a class="logo header__logo" href="/bem.info/ru/"><svg class="logo__logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 101.7 84"><path d="M0 13h23.8v7H0zM0 0h23.8v7H0zm42.7 25.9H0v7h41.1c4.5 0 15 .1 18.9 6.4v-3.9c-1.9-6.2-7.5-9.5-17.3-9.5zm.1 13H0v7h41.1c10 0 16.3.4 18.9 1.8v-3.1c-2-4.9-10.4-5.7-17.2-5.7zm-.1 33H0v-7h41.1c4.5 0 15-.1 18.9-6.4v3.9c-1.9 6.2-7.5 9.5-17.3 9.5zm.1-13H0v-7h41.1c10 0 16.3-.4 18.9-1.8v3.1c-2 4.9-10.4 5.7-17.2 5.7zM70.4 84h31.4v-4.3H71.3c-2.7 0-9.1-.1-11.4-3.8v2.4C61 82 64.4 84 70.4 84zm-.1-7.9h31.4v-4.3H71.3c-6.1 0-9.9-.2-11.4-1.1v1.9c1.2 3 6.3 3.5 10.4 3.5z"/></svg></a><ul class="lang-switcher header__lang"><li class="lang-switcher__item"><a class="lang-switcher__link" href="/bem.info/en/methodology/solved-problems/">en</a></li><li class="lang-switcher__item"><span class="lang-switcher__current">ru</span></li></ul><a class="header__forum" href="/bem.info/ru/forum/">Форум</a></div><div class="search header__search i-bem" data-bem='{"search":{}}'><form class="form search__form search__form_site_methodology i-bem" data-bem='{"form":{}}' action="https://yandex.ru/sitesearch"><span class="input input_type_search i-bem" data-bem='{"input":{}}'><span class="input__box"><input class="input__control" name="text" placeholder="Искать" autocomplete="off" type="search"/></span></span><input type="hidden" name="reqenc"/><input type="hidden" name="searchid" value="1944806"/><input type="hidden" name="l10n" value="ru"/><div class="search-icon search__submit"><svg viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><circle cx="7" cy="7" r="6"/><path d="M11 11l5 5"/></svg></div></form></div><div class="header__menu"><ul class="breadcrumbs header__breadcrumbs"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/bem.info/ru/methodology/">Методология</a></li></ul><ul class="nav"><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/key-concepts/">Основные понятия</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/naming-convention/">Соглашение по именованию</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/filesystem/">Файловая система</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/build/">Сборка</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/declarations/">Декларации</a></li><li class="nav__item nav__item_current">Какие проблемы решает</li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/history/">История создания</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/articles/">Статьи</a></li><li class="nav__item"><a class="nav__link" href="/bem.info/ru/methodology/faq/">FAQ</a></li></ul></div><div class="header__toggle search-icon"><span class="header__toggle-line"></span></div></div><div class="sitemap i-bem" data-bem='{"sitemap":{}}'><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_methodology"><a class="sitemap__link" href="/bem.info/ru/methodology/">Методология</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/key-concepts/">Основные понятия</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/naming-convention/">Соглашение по именованию</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/filesystem/">Файловая система</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/build/">Сборка</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/declarations/">Декларации</a></li><li class="sitemap__tree-item-1"><strong class="sitemap__current">Какие проблемы решает</strong></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/history/">История создания</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/articles/">Статьи</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/methodology/faq/">FAQ</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_tools"><a class="sitemap__link" href="/bem.info/ru/tools/">Инструментарий</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/tools/bem/bem-tools/">bem-tools</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/tools/bem/enb-bem/">enb-bem</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link">Модули</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="/bem.info/ru/tools/bem/bem-naming/">bem-naming</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_platform"><a class="sitemap__link">Платформа</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link">Технологии</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/ru/technology/i-bem/v2/i-bem-js/">i-bem.js</a></li><li class="sitemap__tree-item-2"><a class="sitemap__link" href="/bem.info/ru/technology/deps/about/">DEPS</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/ru/technology/bemjson/v2/bemjson/">BEMJSON</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/ru/technology/bemhtml/v2/intro/">BEMHTML</a></li><li class="sitemap__tree-item-3"><a class="sitemap__link" href="/bem.info/ru/technology/bemtree/v2/bemtree/">BEMTREE</a></li><div class="sitemap__tree-item-0"><a class="sitemap__link" href="/bem.info/ru/libs/">Библиотеки</a></div><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/libs/bem-core/">bem-core</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/libs/bem-components/">bem-components</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/libs/bem-history/">bem-history</a></li></ul></div><div class="sitemap__section"><h1 class="sitemap__title sitemap__title_site_community"><a class="sitemap__link" href="/bem.info/ru/community/">Сообщество</a></h1><ul class="sitemap__tree"><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/blog/">Блог</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/events/">События</a></li><li class="sitemap__tree-item-1"><a class="sitemap__link" href="/bem.info/ru/forum/">Форум</a></li></ul></div></div><div class="article-wrap"><div class="article"><ul class="article-tags"><li class="article-tags__tag"><a class="article-tags__link" href="/bem.info/ru/tags/methodology">methodology</a></li></ul><h1 class="article__heading article__heading_1" id="Решение-распространенных-проблем-веб-разработки-с-помощью-БЭМ"><a href="#Решение-распространенных-проблем-веб-разработки-с-помощью-БЭМ" class="article__heading-anchor"></a>Решение распространенных проблем веб-разработки с помощью БЭМ</h1><p>Методология БЭМ задает <a href="/methodology/naming-convention/">правила по именованию CSS-селекторов</a>, соблюдение которых решает ряд проблем веб-разработки и отвечает на следующие вопросы:</p>
<ul>
<li><a href="#Как-упростить-код-и-облегчить-рефакторинг">Как упростить код и облегчить рефакторинг</a></li>
<li><a href="#Как-получить-самодокументируемый-код">Как получить самодокументируемый код</a></li>
<li><a href="#Как-начать-повторно-использовать-код-и-избежать-взаимного-влияния-компонентов-друг-на-друга">Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга</a></li>
<li><a href="#Как-разместить-несколько-сущностей-на-одном-dom-узле-и-избежать-copy-paste">Как разместить несколько сущностей на одном DOM-узле и избежать «Copy-Paste»</a></li>
</ul>
<h2 class="article__heading article__heading_2" id="Как-упростить-код-и-облегчить-рефакторинг"><a href="#Как-упростить-код-и-облегчить-рефакторинг" class="article__heading-anchor"></a>Как упростить код и облегчить рефакторинг</h2><p><strong>Проблема</strong></p>
<p>При верстке проекта компоненты интерфейса получают имена на основе контекста, с которым работает разработчик. Обычно контекстом служит страница или какая-то ее часть.</p>
<p>Когда страницу верстает один разработчик в короткие сроки, коллизии имен можно избежать. Но если над проектом работают несколько человек или правки нужно внести спустя какое-то время, то отследить зависимые имена компонентов становится сложно. В больших проектах результатом правки одного класса может стать десяток «разъехавшихся» страниц.</p>
<p>Например, для создания навигационного меню могут использоваться следующие имена классов:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>К ним могут быть написаны CSS-правила:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>Если понадобится добавить на страницу другой компонент, содержащий пункты, то стили для нового <code>item</code> повлияют на пункты из существующего навигационного меню.</p>
<p>Или предположим, что в навигационном меню нужно изменить правила класса <code>.active</code>. По имени непонятно, какие компоненты его используют. Может оказаться, что на другой странице существует, например, кнопка <code>&lt;div class=&quot;button active&quot;&gt;Нажми меня!&lt;/div&gt;</code>. Тогда изменение правил для <code>.active</code> повлияет на стили этой кнопки.</p>
<p>Чтобы разобраться, можно ли безболезненно изменить стили для класса <code>.active</code>, разработчику придется просмотреть всю структуру страницы или проекта. Любое изменение потребует значительных временных затрат только на поиск зависимых компонентов.</p>
<p><strong>Решение</strong></p>
<p>Методология БЭМ решает проблему коллизии имен при помощи <a href="/methodology/naming-convention#Соглашение-по-именованию-css-селекторов">соглашения по именованию CSS-классов</a>, предоставляя всем компонентам и их составляющим уникальные имена.</p>
<p>Применение правил по именованию позволяет:</p>
<ul>
<li>задавать уникальные имена <a href="/methodology/key-concepts#БЭМ-сущность">БЭМ-сущностям</a>;</li>
<li>отслеживать иерархические связи в пределах блока;</li>
<li>упрощать восприятие кода;</li>
<li>получать <a href="#Как-получить-самодокументируемый-код">самодокументируемый код</a>.</li>
</ul>
<p>Рассмотрим тот же пример навигационного меню:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Но применим к нему правила именования БЭМ: класс <code>nav</code> будет обозначать имя блока, <code>nav__item</code> и <code>nav__link</code> — имена элементов, а <code>nav__item_active</code> — имя модификатора элемента <code>item</code>.</p>
<p>В таком случае запись будет следующей:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item nav__item_active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>И, соответственно, CSS будет иметь такой вид:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.nav__item_active</span>
{
    <span class="hljs-attribute">font-weight</span>: bold;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffc7c7</span>;
}
</code></pre>
<p>Новые имена CSS-классов содержат всю информацию о структуре блока. А это значит, что больше не нужно просматривать HTML-код страницы, чтобы определить все зависимости. Cелектор всегда содержит знания о том, на какой блок или элемент влияют его правила (в данном случае на элемент <code>nav__item</code>). Разработчику не придется думать о возможном существовании кнопки <code>&lt;div class=&quot;button active&quot;&gt;Нажми меня!&lt;/div&gt;</code>, так как еe CSS-правила будут записаны как <code>.button_active</code> и не будут зависеть от правил модификатора <code>active</code> для пункта меню (<code>nav__item_active</code>).</p>
<blockquote>
<p>Использование длинных имен имеет следующие недостатки:</p>
<ul>
<li><p>Результирующий код весит больше. Эта проблема решается <code>gzip</code>, который сжимает повторяющиеся последовательности в именах.</p>
</li>
<li><p>Времени на написание классов тратится больше. Эту проблему помогают решить автозаполнение в редакторе, использование CSS-препроцессоров и шаблонизаторов, которые автоматически добавляют префиксы. Длинные имена классов предоставляют явные связи между составными частями компонентов, что экономит время на изучение архитектуры проекта.</p>
</li>
</ul>
</blockquote>
<h3 class="article__heading article__heading_3" id="Как-получить-самодокументируемый-код"><a href="#Как-получить-самодокументируемый-код" class="article__heading-anchor"></a>Как получить самодокументируемый код</h3><p><strong>Проблема</strong></p>
<p>При переходе на новый проект разработчик тратит много усилий на то, чтобы понять, как все устроено, где что лежит и как работает код. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки.</p>
<p><strong>Решение</strong></p>
<p>Одна из целей БЭМ — дать понять, что делает тот или иной код, только по названиям классов. Идея самодокументируемого кода заключается в том, чтобы при просмотре CSS-классов, переменных и функций было понятно, как работает код, и как взаимодействуют компоненты интерфейса.</p>
<p>Используя БЭМ, можно получить HTML с именами классов, показывающих взаимодействие следующих частей кода:</p>
<ul>
<li>независимых <a href="/methodology/key-concepts#Блок">блоков</a>;</li>
<li><a href="/methodology/key-concepts#Элемент">элементов</a> (дочерних компонентов) этого блока;</li>
<li><a href="/methodology/key-concepts#Модификатор">модификаторов</a> блока или элемента.</li>
</ul>
<p>Рассмотрим пример с формой поиска на сайте. Не будем обращаться к HTML, попытаемся прочитать только CSS и понять, какую часть интерфейса он описывает.</p>
<p>Вариант реализации формы в классической верстке:</p>
<pre><code class="lang-css"><span class="hljs-selector-tag">form</span> {}

<span class="hljs-selector-tag">input</span>
{
    <span class="hljs-attribute">background</span>: red;
}

<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=submit]</span>
{
    <span class="hljs-attribute">background</span>: buttonface
}
</code></pre>
<p>Такой способ записи не отражает связи между:</p>
<ul>
<li>компонентами и их составными частями;</li>
<li>селекторами и конкретными компонентами интерфейса, к которым они относятся.</li>
</ul>
<p>Использование глобальных селекторов делает код проекта нерасширяемым, так как внесение минимальных изменений повлечет за собой правки во всех зависимых правилах.</p>
<p>Напишем CSS на классы:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.field</span> {}
<span class="hljs-selector-class">.submit</span> {}
</code></pre>
<p>Код стал информативнее: теперь понятно, что есть форма, поле и какой-то компонент <code>submit</code>. Но такие имена все еще не дают понять, относится ли поле (<code>field</code>) к форме (<code>form</code>), или что произойдет, если полей или форм на странице будет несколько. Снова возникает необходимость обращаться к HTML.</p>
<p>Перепишем пример, используя <a href="/methodology/naming-convention/">соглашение по именованию БЭМ</a>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.form</span> {}
<span class="hljs-selector-class">.form_search</span> {}
<span class="hljs-selector-class">.form__field</span> {}
<span class="hljs-selector-class">.form__submit-button</span> {}
</code></pre>
<p>Такая запись дает понять, как работает данный код. Имена CSS-классов показывают, что:</p>
<ul>
<li>Существует форма, реализованная блоком <code>form</code>.</li>
<li>Модификатор <code>form_search</code> указывает на то, что речь идет о форме поиска.</li>
<li>У формы есть составляющие — вложенные элементы: поле <code>form__field</code> и кнопка <code>form__submit-button</code>.</li>
</ul>
<p>Следование соглашению по именованию БЭМ позволяет понять структуру блока без подробного изучения HTML. Даже при появлении на странице еще одного поля (кроме <code>form__field</code>), его правила никак не будут влиять на элементы поисковой формы. Новое поле будет реализовано как элемент другого блока и будет иметь свое уникальное имя. Например, <code>attach__field</code>.</p>
<p>Правила именования БЭМ позволяют сделать код проекта однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков.</p>
<h2 class="article__heading article__heading_2" id="Как-начать-повторно-использовать-код-и-избежать-взаимного-влияния-компонентов-друг-на-друга"><a href="#Как-начать-повторно-использовать-код-и-избежать-взаимного-влияния-компонентов-друг-на-друга" class="article__heading-anchor"></a>Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга</h2><p><strong>Проблема</strong></p>
<p>Разработчик использует схожий набор компонентов при разработке страниц одного проекта. Например, на странице может быть несколько типов блока <code>menu</code>.</p>
<p>Рассмотрим проблему на примере навигационного меню:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>CSS-стили к пункту <code>item</code> могут быть записаны как:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>Если на страницу понадобится добавить дополнительные компоненты, содержащие пункты, то появится еще один блок кода с классом <code>item</code>, например:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>В этом случае CSS может быть оформлен с помощью каскадов. Для этого достаточно доопределить правила, уже написанные для <code>.item</code>:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}

<span class="hljs-selector-class">.snippets</span> <span class="hljs-selector-class">.item</span>
{
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Подобный код может работать до тех пор, пока не возникнет необходимость изменить страницу. Например, переместить пункты меню, использовать написанный код в другом месте отдельно от родительского компонента или вложить навигационное меню в блок <code>snippets</code>.</p>
<p>Использование каскадов связывает независимые компоненты интерфейса: нет возможности исправить один компонент, не затронув стили другого.</p>
<p><strong>Решение</strong></p>
<p><a href="/methodology/naming-convention/">Правила по именованию CSS-селекторов</a> дают возможность вносить изменения точечно, не затрагивая зависимые компоненты. В БЭМ каждый блок имеет уникальное имя и является самодостаточным.</p>
<p>Запишем тот же код в соответствии с правилами именования БЭМ:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: black;
}
</code></pre>
<p>В таком случае добавление нового пункта <code>item</code> на страницу будет выглядеть так:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__item"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snippets__thumb"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Пункт <code>snippets__item</code> будет иметь соответствующие только ему уникальные CSS-правила:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.snippets__item</span>
{
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
}
</code></pre>
<p>Изменения в <code>nav__item</code> не влияют на <code>snippets__item</code>, так как пункты получают уникальные имена благодаря <a href="https://ru.wikipedia.org/wiki/Пространство_имён_%28программирование%29">пространству имен</a>, заданному именем блока. Это позволяет формировать независимые CSS-правила для всех элементов блока.</p>
<p>Такой подход дает возможность защитить элементы от взаимного влияния друг на друга — элементы всегда являются частью блока. Такой же принцип работы использует и Shadow DOM в Web Components. Но, в отличие от Shadow DOM, применение соглашения по именованию БЭМ не зависит от совместимости с работой браузеров.</p>
<p>Блоки <code>snippets</code> и <code>nav</code> можно повторно использовать и перемещать по странице или проекту. Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.</p>
<h3 class="article__heading article__heading_3" id="Использование-каскадов-в-БЭМ"><a href="#Использование-каскадов-в-БЭМ" class="article__heading-anchor"></a>Использование каскадов в БЭМ</h3><p>Методология БЭМ допускает использование каскадов.</p>
<p>Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или заданной ему темы:</p>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_hovered</span> <span class="hljs-selector-class">.nav__link</span>
{
    <span class="hljs-attribute">text-decoration</span>: underline;
}
</code></pre>
<pre><code class="lang-css"><span class="hljs-selector-class">.nav_theme_islands</span> <span class="hljs-selector-class">.nav__item</span>
{
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;
}
</code></pre>
<hr>
<p><strong>Важно!</strong> Применение каскада увеличивает связанность кода и делает его повторное использование невозможным.</p>
<hr>
<h2 class="article__heading article__heading_2" id="Как-разместить-несколько-сущностей-на-одном-dom-узле-и-избежать-«copy-paste»"><a href="#Как-разместить-несколько-сущностей-на-одном-dom-узле-и-избежать-«copy-paste»" class="article__heading-anchor"></a>Как разместить несколько сущностей на одном DOM-узле и избежать «Copy-Paste»</h2><p><strong>Проблема</strong></p>
<p>При работе с проектами может потребоваться повторно использовать реализованную функциональность.</p>
<p>Во многих случаях такую проблему решают копированием нужной части кода в новый компонент. Такой подход имеет следующие недостатки:</p>
<ul>
<li>увеличивается кодовая база проекта;</li>
<li>затрудняется отладка кода при выявлении ошибки.</li>
</ul>
<p>Как следствие, разработчик вынужден поддерживать большее количество строк кода, а исправления необходимо вносить отдельно в каждую реализацию. Это увеличивает временные затраты на отладку и поддержку проекта.</p>
<p><strong>Решение</strong></p>
<p>Воспользуемся примером, который реализует универсальный блок навигационного меню и написан по всем <a href="/methodology/naming-convention/">правилам именования БЭМ</a>.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Такой блок можно использовать, например, для навигации по статьям в блоке новостей.</p>
<p>Допустим, в разделе новостей уже есть блок <code>articles</code>, которому написаны все необходимые CSS-правила.</p>
<p>Смешать реализации двух разных блоков без копирования кода можно при помощи <a href="/methodology/key-concepts#Микс">микса</a>. То есть разместить на одном DOM-узле блок <code>nav</code> и элемент <code>articles__nav</code>.</p>
<p>В коде это будет выглядеть так:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav articles__nav"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav__link"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>Такая реализация позволит объединить функциональность блока <code>nav</code> и особенности реализации элемента <code>articles__nav</code> (внешний вид новостных статей в меню). При этом нет необходимости копировать уже имеющиеся CSS-правила. При обнаружении ошибки, правки необходимо будет внести только в одну часть кода.</p>
<blockquote>
<p>Миксовать можно не только блоки с элементами, но и другие БЭМ-сущности. Подробнее о вариантах использования миксов в БЭМ читайте в разделе <a href="/methodology/key-concepts#Микс">Основные понятия БЭМ</a>.</p>
</blockquote>
</div><ul class="article-rewind"><li class="article-rewind__prev"><a class="article-rewind__prev-link" href="/bem.info/ru/methodology/declarations/">Декларации</a></li> <li class="article-rewind__next"><a class="article-rewind__next-link" href="/bem.info/ru/methodology/history/">История создания</a></li></ul><div class="article-amendments">Если вы заметили ошибку или хотите чем-то дополнить статью, вы всегда можете или написать нам об этом на <a class="article-amendments__issue" href="https://github.com/bem/bem-method/issues/new">Гитхабе</a>, или поправить статью с помощью <a class="article-amendments__edit" href="http://prose.io/#bem/bem-method/blob/bem-info-data/method/solved-problems/solved-problems.ru.md">prose.io.</a></div><div class="social-likes"><a class="social-likes__text">Поделиться c миром: </a><a class="social-likes__service social-likes__service_type_facebook" href="https://www.facebook.com/sharer.php?s=100&amp;url=https%3A%2F%2Fru.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B%20%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82&amp;image=">Facebook</a> <a class="social-likes__service social-likes__service_type_vk" href="http://vk.com/share.php?&amp;url=https%3A%2F%2Fru.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B%20%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82&amp;image=">VKontakte</a> <a class="social-likes__service social-likes__service_type_twitter" href="https://twitter.com/share?&amp;url=https%3A%2F%2Fru.bem.info%2Fmethodology%2Fsolved-problems%2F&amp;title=%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B%20%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82&amp;image=">Twitter</a></div></div><footer class="footer page-bg"><div class="legos legos_inverted"><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_2"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_height_2"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_2"></div><div class="legos__lego legos__lego_height_3"></div><div class="legos__lego"></div><div class="legos__lego"></div><div class="legos__lego legos__lego_width_3"></div><div class="legos__lego legos__lego_width_2 legos__lego_height_3"></div><div class="legos__lego legos__lego_width_2"></div><div class="legos__lego legos__lego_width_3 legos__lego_height_2"></div></div><div class="footer__layout"><ul class="footer__community"><li class="footer__channel"><a class="footer__channel-link" href="https://web-standards.slack.com/messages/bem/">Slack</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://telegram.me/bem_ru">Telegram</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://www.facebook.com/groups/bem.info/">Facebook</a></li><li class="footer__channel"><a class="footer__channel-link" href="https://twitter.com/bem_ru/">Twitter</a></li></ul></div></footer><script>(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter16972024 = new Ya.Metrika({"id":"16972024","webvisor":true,"clickmap":true,"trackLinks":true,"accurateTrackBounce":true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/16972024" style="position:absolute; left:-9999px;"/></div></noscript><script src="/bem.info/ru/methodology.ru.min.js"></script></body></html>